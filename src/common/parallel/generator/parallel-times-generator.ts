import { IParallelGenerator } from "./parallel-generator";
import { FunctionCallSerializer } from "../../function/function-call-serializer";
import { ISerializedFunctionCall } from "../../function/serialized-function-call";
import { ParallelWorkerFunctionIds } from "../slave/parallel-worker-functions";
import { FunctionCall } from "../../function/function-call";
import { IParallelTaskEnvironment } from "../";
import { IFunctionId, isFunctionId } from "../../function/function-id";

/**
 * Generic generator that calls a passed in function n times to create n values
 */
export class ParallelTimesGenerator implements IParallelGenerator {
	public static create<TResult>(
		n: number,
		generator: (
			this: void,
			index: number,
			env: IParallelTaskEnvironment,
		) => TResult,
	): ParallelTimesGenerator;
	public static create<T>(n: number, value: T): ParallelTimesGenerator;
	public static create(n: number, call: FunctionCall): ParallelTimesGenerator;
	public static create<T>(
		n: number,
		generator:
			| ((this: void, index: number, env: IParallelTaskEnvironment) => T)
			| IFunctionId
			| T,
	): ParallelTimesGenerator {
		let generatorFunction: FunctionCall;
		if (isFunctionId(generator) || typeof generator === "function") {
			generatorFunction = FunctionCall.createUnchecked(generator);
		} else {
			generatorFunction = FunctionCall.create(
				ParallelWorkerFunctionIds.IDENTITY,
				generator,
			);
		}

		return new ParallelTimesGenerator(n, generatorFunction);
	}

	public readonly times: number;
	public readonly iteratee: FunctionCall;

	/**
	 * Creates a new times generator that repeats the value generated by the iteratee n times.
	 * @param n the number of times the value should be repeated
	 * @param iteratee function that is called n times and generates the value or a constant value that is repeated
	 */
	private constructor(n: number, iteratee: FunctionCall) {
		this.times = n;
		this.iteratee = iteratee;
	}

	get length(): number {
		return this.times;
	}

	public serializeSlice(
		index: number,
		numberOfItems: number,
		functionCallSerializer: FunctionCallSerializer,
	): ISerializedFunctionCall {
		const sliceStart = index * numberOfItems;
		const sliceEnd = Math.min(sliceStart + numberOfItems, this.times);
		const iterateeFunction = functionCallSerializer.serializeFunctionCall(
			this.iteratee,
		);

		return functionCallSerializer.serializeFunctionCall(
			FunctionCall.create(
				ParallelWorkerFunctionIds.TIMES,
				sliceStart,
				sliceEnd,
				iterateeFunction,
			),
		);
	}
}
